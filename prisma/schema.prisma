generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String         @id @default(uuid())
  email             String         @unique
  firstName         String
  lastName          String
  password          String?
  phoneNumber       String?        @unique
  profilePic        String?
  address           String?
  city              String?
  state             String?
  country           String?         @default("Nigeria")
  role              RoleEnum       @default(RENTER)
  permissions       PermissionEnum[]
  provider          ProviderEnum   @default(EMAIL)
  providerAccounts  ProviderAccount[] 
  isVerified        Boolean        @default(false)
  isActive          Boolean        @default(true)
  status            UserStatus     @default(ACTIVE)
  refreshToken      String?
  lastLogin         DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  wallet                  Wallet?
  properties              Property[]
  propertyLikes           PropertyLike[]
  propertyViews           PropertyView[]
  identityVerifications   IdentityVerification[]
  propertyOwnershipProofs PropertyOwnershipProof[]
  verificationTokens      VerificationToken[]
  notifications           Notification[]
  userConversations       UserConversation[]     // Join table for User-Conversation relationship
  sentMessages            Message[]              @relation("SentMessages")
  adminActionLogs         AdminActionLog[]
  transactions            Transaction[]
  processedRefunds        Refund[]               @relation("ProcessedRefunds")
  renterBookings          Booking[]              @relation("RenterBookings")
  initiatedDisputes       Dispute[]              @relation("InitiatedDisputes")
  createdAds              Ad[]
  auditLogs               AuditLog[]             @relation("UserAuditLogs")
  settingUpdates          PlatformSetting[]      @relation("SettingUpdates")
  contentUpdates          ContentPage[]          @relation("ContentUpdates")
  faqUpdates              FAQ[]                  @relation("FAQUpdates")
  templateUpdates         EmailTemplate[]        @relation("TemplateUpdates")
  presence                UserPresence?
  presenceHistory         UserPresenceHistory[]

  @@map("users")
}

model Conversation {
  id            String             @id @default(uuid())
  propertyId    String?
  isActive      Boolean            @default(true)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  // Relations
  property        Property?          @relation(fields: [propertyId], references: [id], onDelete: SetNull, name: "ConversationProperty")
  participants    UserConversation[] // References User through join table
  messages        Message[]

  @@map("conversations")
}

model UserConversation {
  id             String       @id @default(uuid())
  userId         String
  conversationId String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  lastReadAt     DateTime?
  isArchived     Boolean      @default(false)
  isMuted        Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@unique([userId, conversationId])
  @@map("user_conversations")
}

model Message {
  id             String       @id @default(uuid())
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  conversationId String
  sender         User         @relation("SentMessages", fields: [senderId], references: [id])
  senderId       String
  content        String
  messageType    MessageType  @default(TEXT)
  attachments    String[]     @default([])
  isRead         Boolean      @default(false)
  propertyId     String?
  property       Property?    @relation(fields: [propertyId], references: [id], name: "MessageProperty")
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([conversationId])
  @@index([senderId])
  @@map("messages")
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  DOCUMENT
  LOCATION
  SYSTEM
}

model ProviderAccount {
  id          String       @id @default(uuid())
  userId      String
  provider    ProviderEnum
  providerId  String
  accessToken String
  user        User         @relation(fields: [userId], references: [id])
  
  @@unique([provider, providerId])
  @@map("provider_accounts")
}

model Property {
  id                    String             @id @default(uuid())
  title                 String
  description           String
  status                PropertyStatus     @default(DRAFT)
  listingType           PropertyListingType @default(RENT) 
  amount                Float
  rentalPeriod          RentalPeriod
  address               String
  city                  String
  state                 String
  country               String             @default("Nigeria")
  latitude              Float?
  longitude             Float?
  sqft                  Float?
  bedrooms              Int?
  bathrooms             Int
  propertyType          PropertyType
  roomType              RoomType
  visitingDays          DayOfWeek[]
  visitingTimeStart     String?
  visitingTimeEnd       String?
  amenities             String[]
  isFurnished           Boolean            @default(false)
  isForStudents         Boolean            @default(false)
  images                String[]           @default([])
  livingRoomImages      String[]           @default([])
  bedroomImages         String[]           @default([])
  bathroomImages        String[]           @default([])
  video                 String?            
  propertyOwnershipDocs String[]           @default([])
  propertyPlanDocs      String[]           @default([])
  propertyDimensionDocs String[]           @default([])
  ownershipVerified     Boolean            @default(false)
  featured              Boolean            @default(false)
  ownerId               String
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  // Relations
  owner                   User                     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  transactions            Transaction[]
  bookings                Booking[]
  likes                   PropertyLike[]
  views                   PropertyView[]
  ownershipProofs         PropertyOwnershipProof[]
  conversations           Conversation[]           @relation("ConversationProperty") // Opposite relation for Conversation
  messages                Message[]                @relation("MessageProperty")     // Opposite relation for Message

  @@map("properties")
}

model UserPresence {
  id        String   @id @default(cuid())
  userId    String   @unique
  isOnline  Boolean  @default(false)
  lastSeen  DateTime
  socketId  String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_presence")
}

model UserPresenceHistory {
  id        String   @id @default(cuid())
  userId    String
  status    String   // 'online' or 'offline'
  timestamp DateTime @default(now())
  
  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_presence_history")
}

model PropertyLike {
  id         String   @id @default(uuid())
  userId     String
  propertyId String
  createdAt  DateTime @default(now())

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([userId, propertyId])
  @@map("property_likes")
}

model PropertyView {
  id         String   @id @default(uuid())
  userId     String
  propertyId String
  viewedAt   DateTime @default(now())

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([userId, propertyId])
  @@map("property_views")
}

model IdentityVerification {
  id               String             @id @default(uuid())
  userId           String
  documentType     DocumentType
  documentNumber   String
  documentImages   String[]
  status           VerificationStatus @default(PENDING)
  reviewedAt       DateTime?
  reviewedBy       String?
  rejectionReason  String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("identity_verifications")
}

model PropertyOwnershipProof {
  id               String             @id @default(uuid())
  propertyId       String
  userId           String
  documentType     String
  documentImages   String[]
  status           VerificationStatus @default(PENDING)
  reviewedAt       DateTime?
  reviewedBy       String?
  rejectionReason  String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  // Relations
  property Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("property_ownership_proofs")
}

model VerificationToken {
  id        String    @id @default(uuid())
  token     String    @unique
  type      TokenType
  userId    String
  email     String
  used      Boolean   @default(false)
  expiresAt DateTime
  createdAt DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("verification_tokens")
}

model Wallet {
  id                  String              @id @default(uuid())
  userId              String              @unique
  balance             Float               @default(0)
  currency            String              @default("NGN")
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  walletTransactions  WalletTransaction[]

  @@map("wallets")
}

model WalletTransaction {
  id                      String                  @id @default(uuid())
  walletId                String
  amount                  Float
  type                    WalletTransactionType
  status                  TransactionStatus       @default(COMPLETED)
  reference               String                  @unique
  description             String?
  relatedTransactionId    String?
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @updatedAt

  wallet                  Wallet                  @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@map("wallet_transactions")
}

model Booking {
  id                  String          @id @default(uuid())
  renterId            String
  propertyId          String
  startDate           DateTime
  endDate             DateTime?
  amount              Float
  status              BookingStatus   @default(PENDING)
  transactions        Transaction[]
  disputes            Dispute[]
  escrowTransactionId String?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  renter              User            @relation("RenterBookings", fields: [renterId], references: [id], onDelete: Cascade)
  property            Property        @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  

  @@map("bookings")
}

model Dispute {
  id            String          @id @default(uuid())
  bookingId     String
  initiatorId   String
  reason        String
  description   String
  status        DisputeStatus   @default(PENDING)
  resolution    String?
  resolvedAt    DateTime?
  resolvedBy    String?
  parentDispute String?         // Renamed from disputeId to be clearer
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  booking       Booking         @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  initiator     User            @relation("InitiatedDisputes", fields: [initiatorId], references: [id], onDelete: Cascade)
  refunds       Refund[]
  parent        Dispute?        @relation("DisputeHierarchy", fields: [parentDispute], references: [id])
  children      Dispute[]       @relation("DisputeHierarchy")

  @@map("disputes")
}

model Transaction {
  id            String            @id @default(uuid())
  type          TransactionType
  amount        Float
  currency      String            @default("NGN")
  status        TransactionStatus @default(PENDING)
  reference     String            @unique
  description   String
  userId        String?
  propertyId    String?
  adId          String?
  bookingId     String?
  metadata      Json?
  paymentMethod String?
  gateway       PaymentGateway?
  gatewayRef    String?
  failureReason String?
  processedAt   DateTime?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Relations
  user     User?     @relation(fields: [userId], references: [id])
  property Property? @relation(fields: [propertyId], references: [id])
  ad       Ad?       @relation(fields: [adId], references: [id])
  booking  Booking?  @relation(fields: [bookingId], references: [id])
  refunds  Refund[]

  @@map("transactions")
}

model Refund {
  id            String       @id @default(uuid())
  transactionId String
  disputeId     String?      // Added relation to disputes
  amount        Float
  reason        String
  status        RefundStatus @default(PENDING)
  processedBy   String?
  processedAt   DateTime?
  createdAt     DateTime     @default(now())

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id])
  dispute     Dispute?    @relation(fields: [disputeId], references: [id])
  processor   User?       @relation("ProcessedRefunds", fields: [processedBy], references: [id])

  @@map("refunds")
}

model Ad {
  id           String        @id @default(uuid())
  title        String
  description  String?
  imageUrl     String
  targetUrl    String
  position     AdPosition
  type         AdType        @default(STANDARD)
  status       AdStatus      @default(PENDING)
  startDate    DateTime
  endDate      DateTime
  budget       Float?
  costPerClick Float?
  isActive     Boolean       @default(false)
  createdBy    String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  // Relations
  creator      User           @relation(fields: [createdBy], references: [id])
  transactions Transaction[]
  analytics    AdAnalytics[]

  @@map("ads")
}

model AdAnalytics {
  id          String   @id @default(uuid())
  adId        String
  date        DateTime @db.Date
  impressions Int      @default(0)
  clicks      Int      @default(0)
  conversions Int      @default(0)
  revenue     Float    @default(0)
  createdAt   DateTime @default(now())

  // Relations
  ad Ad @relation(fields: [adId], references: [id], onDelete: Cascade)

  @@unique([adId, date])
  @@map("ad_analytics")
}

model AuditLog {
  id         String      @id @default(uuid())
  userId     String
  action     AuditAction
  resource   String
  resourceId String?
  oldValues  Json?
  newValues  Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime    @default(now())

  // Relations
  user User @relation("UserAuditLogs", fields: [userId], references: [id])

  @@map("audit_logs")
}

model PlatformSetting {
  id          String   @id @default(uuid())
  key         String   @unique
  value       Json
  description String?
  category    String
  isPublic    Boolean  @default(false)
  updatedBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  updater User @relation("SettingUpdates", fields: [updatedBy], references: [id])

  @@map("platform_settings")
}

model ContentPage {
  id        String        @id @default(uuid())
  slug      String        @unique
  title     String
  content   String
  type      ContentType
  status    ContentStatus @default(DRAFT)
  isPublic  Boolean       @default(false)
  seoTitle  String?
  seoDesc   String?
  updatedBy String
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  // Relations
  updater User @relation("ContentUpdates", fields: [updatedBy], references: [id])

  @@map("content_pages")
}

model FAQ {
  id        String   @id @default(uuid())
  question  String
  answer    String
  category  String
  order     Int      @default(0)
  isActive  Boolean  @default(true)
  updatedBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  updater User @relation("FAQUpdates", fields: [updatedBy], references: [id])

  @@map("faqs")
}

model EmailTemplate {
  id          String   @id @default(uuid())
  name        String   @unique
  subject     String
  htmlContent String
  textContent String?
  variables   String[] @default([])
  isActive    Boolean  @default(true)
  updatedBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  updater User @relation("TemplateUpdates", fields: [updatedBy], references: [id])

  @@map("email_templates")
}


model Notification {
  id        String           @id @default(uuid())
  userId    String
  title     String
  message   String
  type      NotificationType
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model AdminActionLog {
  id        String   @id @default(uuid())
  adminId   String
  action    String
  data      Json?
  createdAt DateTime @default(now())

  admin User @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@map("admin_action_logs")
}

// Enums
enum RoleEnum {
  RENTER
  LISTER
  ADMIN
}

enum PermissionEnum {
  READ_USERS
  WRITE_USERS
  DELETE_USERS
  READ_PROPERTIES
  WRITE_PROPERTIES
  DELETE_PROPERTIES
  MANAGE_VERIFICATIONS
  VIEW_ANALYTICS
  SUPER_ADMIN
}

enum ProviderEnum {
  EMAIL
  GOOGLE
  FACEBOOK
  LINKEDIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
  PENDING_VERIFICATION
}

enum PropertyStatus {
DRAFT
  PENDING_REVIEW
  ACTIVE
  RENTED
  INACTIVE
  REJECTED
  SUSPENDED
  PENDING_BOOKING 
}

// Added missing enum for property listing type
enum PropertyListingType {
  RENT
  LEASE
  SALE
}

enum PropertyType {
  BUNGALOW
  TWO_STORY
  THREE_STORY
  FOUR_STORY
  SIX_PLUS_STORY
  APARTMENT
  DUPLEX
  MANSION
}

enum RoomType {
  STUDIO
  ONE_BEDROOM
  TWO_BEDROOM
  THREE_BEDROOM
  FOUR_BEDROOM
  FIVE_PLUS_BEDROOM
  SELF_CONTAIN
}

enum RentalPeriod {
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum DocumentType {
  NIN
  DRIVERS_LICENSE
  INTERNATIONAL_PASSPORT
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum TokenType {
  EMAIL_VERIFICATION
  PASSWORD_RESET
  PHONE_VERIFICATION
}

enum TransactionType {
  PREMIUM_LISTING
  BASIC_LISTING  
  FEATURED_LISTING
  AD_PLACEMENT
  API_ACCESS
  SUBSCRIPTION
  DEPOSIT
  WITHDRAWAL
  ESCROW_RELEASE
  ESCROW_HOLD
  ESCROW_REFUND
  REFUND
  RENT_PAYMENT
  PLATFORM_FEE 
}

enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
  HELD
  RELEASED
}

enum PaymentGateway {
  PAYSTACK
  FLUTTERWAVE
  STRIPE
  PAYPAL
}

enum RefundStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSED
}

enum WalletTransactionType {
  RENT_PAYMENT
  WITHDRAWAL
  DEPOSIT
  REFUND
  ESCROW_RELEASE
  PLATFORM_FEE 
}

enum AdPosition {
  HEADER_BANNER
  SIDEBAR_TOP
  SIDEBAR_BOTTOM
  CONTENT_TOP
  CONTENT_MIDDLE
  CONTENT_BOTTOM
  FOOTER
  POPUP
  FLOATING
}

enum AdType {
  STANDARD
  PREMIUM
  SPONSORED
}

enum AdStatus {
  PENDING
  APPROVED
  REJECTED
  ACTIVE
  PAUSED
  EXPIRED
}

enum AuditAction {
  CREATE
  READ
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  APPROVE
  REJECT
  SUSPEND
  ACTIVATE
  EXPORT
}

enum ContentType {
  PAGE
  POLICY
  TERMS
  FAQ
  HELP
  LANDING
}

enum ContentStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum NotificationType {
  EMAIL
  PROPERTY_APPROVED
  PROPERTY_REJECTED
  NEW_MESSAGE
  PROPERTY_LIKED
  PROPERTY_VIEWED
  VERIFICATION_APPROVED
  VERIFICATION_REJECTED
  ACCOUNT_SUSPENDED
  ACCOUNT_REACTIVATED
  PROPERTY_INQUIRY
  SYSTEM_UPDATE
  BOOKING_CREATED
  PAYMENT_CONFIRMED
  PAYMENT_RECEIVED
  ESCROW_RELEASED
  SYSTEM_AUTO_RELEASE
  DISPUTE_CREATED
  DISPUTE_RESOLVED
  REFUND_CREATED
  REFUND_APPROVED
  REFUND_REJECTED
  REFUND_PROCESSED
  WITHDRAWAL_REQUESTED
  WITHDRAWAL_APPROVED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  ACTIVE
  COMPLETED
  CANCELLED
  DISPUTED
}

enum DisputeStatus {
  PENDING
  IN_REVIEW
  RESOLVED
  REJECTED
}